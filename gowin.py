# 
# This file is created by tcjie tcjie@sohu.com
#
# 


from abc import abstractproperty

from amaranth.hdl import *
# from amaranth.lib.cdc import ResetSynchronizer
from amaranth.build import *

__all__ = ["GowinPlatform"]


class GowinPaltform(TemplatedPlatform):
    toolchain = "gw_sh"

    device = abstractproperty()             # GW1NSR-4C
    pn = abstractproperty()                 # GW1NSR-LV4CQN48PC6/I5

    @property
    def _part(self):
        return "{} {}".format(self.device,self.pn)

    _gw_required_tools = [
        "gw_sh",
    ]

    _gw_file_templates = {
        **TemplatedPlatform.build_script_templates,
        "build_{{name}}.sh":r"""
        # {{ autogenerated}}
        set -e{{verbose("x")}}
        if [ -z "$BASH" ]; then exec /bin/bash "$0" "$@"; fi
        [ -n "${{platform._deprecated_toolchain_env_var}} ] && . "${{platform._deprecated_toolchain_env_var}}"
        [ -n "${{platform._toolchain_env_var}}" ] && . "${{platform._toolchain_env_var}}"
        {{emit_commands("sh")}}
        """,
        "{{name}}.v": r"""
            /* {{autogenerated}} */
            {{emit_verilog()}}
        """,
        "{{name}}.debug.v": r"""
         /* {{autogenerated}} */
         {{emit_debug_verilog()}}
        """,
        "{{name}}.tcl": r"""
            # {{autogenerated}}
            {% for file in platform.iter_files(".v",".sv",".vhd",".vhdl") -%}
                add_file {{file}}
            {% endfor %}
            add_file -type verilog {{name}}.v
            add_file -type cst {{name}}.cst
            add_file -type sdc {{name}}.sdc
            set_device -name {{platform._part}}
            set_option -verilog_std v2001 -print_all_synthesis_warning 1 -show_all_warn 1
            {{get_override("add_options")|default("# (add_options placeholder)")}}
            run all

        """,
        "{{name}}.cst": r"""
            # {{autogenerated}}
            {% for port_name, pin_name, attrs in platform.iter_port_constraints_bits() -%}
                IO_LOC "{{port_name}}" {{pin_name}};
                {% for attr_name, attr_value in attrs.items() -%}
                    IO_PORT "{{port_name}}" {{attr_name}}={{attr_value}};
                {% endfor %}
            {% endfor  %}

        """,
        
        "{{name}}.sdc": r"""
        # {{autogenerated}}
        {% for net_signal,port_signal,frequency in platform.iter_clock_constraints() -%}
            create_clock -name {{port_signal.name|tcl_escape}} -period {{1000000000/frequency}}  [get_ports {{port_signal.name|tcl_escape}}]
        {% endfor %}
        {{get_override("add_constraints")|default("# (add_constraints placeholder)")}}
        """,
    } 
    # create_clock -name clk -period 20 -waveform {0 10} [get_ports {clk}]
    # command_templates = [
    _gw_command_templates = [
        r"""
        {{invoke_tool("gw_sh")}}
             {{name}}.tcl
        """,
    ]
    @property
    def required_tools(self):
        return self._gw_required_tools
    
    @property
    def file_templates(self):
        return self._gw_file_templates

    @property
    def command_templates(self):
        return self._gw_command_templates

    def _get_xdr_buffer(self, m, pin, *, i_invert=False, o_invert = False):
        def get_ireg(clk,d,q):
            for bit in range(len(q)):
                m.submodules += Instance("DFF",
                    i_clk = clk,
                    i_d = d[bit],
                    o_q = q[bit],
                )
        def get_oreg(clk,d,q):
            for bit in range(len(q)):
                m.submodules += Instance("DFF",
                    i_clk = clk,
                    i_d = d[bit],
                    o_q = q[bit]
                )
        def get_iddr(clk,d,q0,q1):
            for bit in range(len(d)):
                m.submodules += Instance("IDDR",
                    i_clk = clk,
                    i_d = d[bit],
                    o_q0 = q0[bit],
                    o_q1 = q1[bit]
                )
        def get_oddr(clk,d0,d1,q):
            for bit in range(len(1)):
                m.submodules += Instance("ODDR",
                    i_clk = clk,
                    i_d0 = d0[bit],
                    i_d1 = d1[bit],
                    o_q0 = q[bit],
                )
        def get_ineg(z, invert):
            if invert:
                a = Signal.like(z,name_suffix = "_n")
                m.d.comb += z.eq(~a)
                return a
            else:
                return z
        def get_oneg(a, invert):
            if invert:
                z = Signal.like(a,name_suffix="_n")
                m.d.comb += z.eq(~a)
                return z
            else:
                return a

        if "i" in pin.dir:
            if pin.xdr < 2:
                pin_i = get_ineg(pin.i, i_invert)
            elif pin.xdr == 2:
                pin_i0 = get_ineg(pin.i0, i_invert)
                pin_i1 = get_ineg(pin.i1, i_invert)
        if "o" in pin.dir:
            if pin.xdr < 2:
                pin_o = get_oneg(pin.o, o_invert)
            elif pin.xdr == 2:
                pin_o0 = get_oneg(pin.o0, o_invert)
                pin_o1 = get_oneg(pin.o1, o_invert)

        i = o = t = None
        if "i" in pin.dir:
            i = Signal(pin.width, name="{}_xdr_i".format(pin.name))
        if "o" in pin.dir:
            o = Signal(pin.width, name="{}_xdr_o".format(pin.name))
        if pin.dir in("oe","io"):
            t = Signal(1,         name="{}_xdr_t".format(pin.name))

        if pin.xdr == 0:
            if "i" in pin.dir:
                i = pin_i
            if "o" in pin.dir:
                o = pin_o
            if pin.dir in ("oe","io"):
                t = ~pin.oe
        elif pin.xdr == 1:
            if "i" in pin.dir:
                get_ireg(pin.i_clk, i, pin_i)
            if "o" in pin.dir:
                get_oreg(pin.o_clk, pin_o, o)
            if pin.dir in ("oe","io"):
                get_oreg(pin.o_clk, ~pin.oe,t)
        elif pin.xdr == 2:
            if "i" in pin.dir:
                get_iddr(pin.i_clk, i, pin_i0, pin_i1)
            if "o" in pin.dir:
                get_oddr(pin.o_clk, pin_o0, pin_o1, o)
            if pin.dir in ("oe","io"):
                get_oreg(pin.o_clk, ~pin.oe, t)
        else:
            assert False

        return (i, o, t)

    def get_input(self, pin, port, attrs, invert):
        m = Module()
        i, o, t = self._get_xdr_buffer(m, pin, i_invert = invert)
        for bit in range(len(port)):
            m.submodules["{}_{}".format(pin.name, bit)] = Instance("IBUF",
                i_I = port.io[bit],
                o_O = i[bit],
            )
        return m
    
    def get_output(self, pin, port, attrs, invert):
        m = Module()
        i, o, t = self._get_xdr_buffer(m, pin, o_invert=invert)
        for bit in range(len(port)):
            m.submodules["{}_{}".format(pin.name,bit)] = Instance("OBUF",
                i_I = o[bit],
                o_O = port.io[bit]
            )
        return m

    def get_tristate(self, pin, port, attrs, invert):
        m = Module()
        i, o, t = self._get_xdr_buffer(m, pin, o_invert=invert)
        for bit in range(len(port)):
            m.submodules["{}_{}".format(pin.name,bit)] = Instance("TBUF",       # low level enable
                i_OEN = t,
                i_I = o[bit],
                o_O = port.io[bit]
            )
        return m

    def get_input_output(self, pin, port, attrs, invert):
        m = Module()
        i, o, t = self._get_xdr_buffer(m, pin, i_invert=invert, o_invert=invert)
        for bit in range(len(port)):
            m.submodules["{}_{}".format(pin.name,bit)] = Instance("IOBUF",
                i_OEN = t,
                i_I = o[bit],
                o_O = i[bit],
                io_IO = port.io[bit],
            )
        return m
    
    def get_diff_input(self, pin, port, attrs, invert):
        m = Module()
        i, o, t = self._get_xdr_buffer(m, pin, i_invert = invert)
        for bit in range(pin.wodth):
            m.submodules["{}_{}".format(pin.name,bit)] = Instance("TLVDS_IBUF",
                i_I = port.p[bit],
                i_IB = port.n[bit],
                o_O = i[bit]
            )
        return m

    def get_diff_output(self, pin, port, attrs, invert):
        m = Module()
        i, o, t = self._get_xdr_buffer(m, pin, o_invert=invert)
        for bit in range(pin.width):
            m.submodules["{}_{}".format(pin.name,bit)] = Instance("TLVDS_OBUF",
                i_I = o[bit],
                o_O = port.p[bit],
                o_OB = port.n[bit],
            )
        return m
    def get_diff_tristate(self, pin, port, attrs, invert):
        m = Module()
        i, o, t = self._get_xdr_buffer(m, pin, o_invert = invert)
        for bit in range(pin.width):
            m.submodules["{}_{}".format(pin.name,bit)] = Instance("TLVDS_TBUF",
                i_OEN = t,
                i_I = o[bit],
                o_O = port.p[bit],
                o_OB = port.n[bit]
            )
        return m

    def get_diff_input_output(self, pin, port, atttr, invert):
        m = Module()
        i, o, t = self._get_xdr_buffer(m, pin, i_invert=invert, o_invert= invert)
        for bit in range(pin.width):
            m.submodules["{}_{}".format(pin.name,bit)] = Instance("TLVDS_IOBUF",
                i_OEN = t,
                i_I = o[bit],
                o_O = i[bit],
                io_IO = port.p[bit],
                io_IOB = port.n[bit]
            )
        return m 